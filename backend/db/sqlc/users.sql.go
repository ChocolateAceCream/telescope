// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: users.sql

package db

import (
	"context"
)

const createNewPasswordLogin = `-- name: CreateNewPasswordLogin :exec
INSERT INTO password_logins (password, email)
VALUES (
  $1,
  $2
)
`

type CreateNewPasswordLoginParams struct {
	Password string
	Email    string
}

func (q *Queries) CreateNewPasswordLogin(ctx context.Context, arg CreateNewPasswordLoginParams) error {
	_, err := q.db.Exec(ctx, createNewPasswordLogin, arg.Password, arg.Email)
	return err
}

const createNewUser = `-- name: CreateNewUser :exec
INSERT INTO users (username, email, info)
VALUES ($1, $2, $3)
ON CONFLICT (email) DO UPDATE
SET
  username = COALESCE(users.username,EXCLUDED.username),
  info = users.info || excluded.info
`

type CreateNewUserParams struct {
	Username string
	Email    string
	Info     []byte
}

func (q *Queries) CreateNewUser(ctx context.Context, arg CreateNewUserParams) error {
	_, err := q.db.Exec(ctx, createNewUser, arg.Username, arg.Email, arg.Info)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one
select id, username, email, info, created_at, updated_at FROM users where email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Info,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
select id, username, email, info, created_at, updated_at FROM users where username = $1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Info,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const initPasswordLogins = `-- name: InitPasswordLogins :exec
insert into password_logins (password, email)
values (
    encode(digest($1, 'sha256'), 'hex'),
    'superadmin@superadmin.com'
  ),
  (
    encode(digest($1, 'sha256'), 'hex'),
    'admin@admin.com'
  ) on conflict(email) do nothing
`

func (q *Queries) InitPasswordLogins(ctx context.Context, digest string) error {
	_, err := q.db.Exec(ctx, initPasswordLogins, digest)
	return err
}

const initUsers = `-- name: InitUsers :exec
insert into users (username, email, info)
values (
    'superadmin',
    'superadmin@superadmin.com',
    '{"role": "super_admin","locale":"en"}'::jsonb
  ),
  (
    'admin',
    'admin@admin.com',
    '{"role": "admin","locale":"en"}'::jsonb
  ) on conflict(email) do update
SET
  username = COALESCE(users.username,EXCLUDED.username),
  info = users.info || excluded.info
`

func (q *Queries) InitUsers(ctx context.Context) error {
	_, err := q.db.Exec(ctx, initUsers)
	return err
}

const verifyUserCredentials = `-- name: VerifyUserCredentials :one
select exists (
  select 1
  from password_logins
  where email = $1 and password = $2
) as valid
`

type VerifyUserCredentialsParams struct {
	Email    string
	Password string
}

func (q *Queries) VerifyUserCredentials(ctx context.Context, arg VerifyUserCredentialsParams) (bool, error) {
	row := q.db.QueryRow(ctx, verifyUserCredentials, arg.Email, arg.Password)
	var valid bool
	err := row.Scan(&valid)
	return valid, err
}
